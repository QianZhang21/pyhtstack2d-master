"""
Very similar to the genInput module. However, shell scripts generated by the current genInputV0 module do not
take into account interruptions in submitt tasks and directly recalculate all calculated material.
In some cases, such as when shell scripts need to be modified manually, shell scripts generated by
the genInputV0 module may be clearer and more convenient, so the genInputV0 module has been retained.


For example, the following is a calculation part of the shell script generated by the genInputV0 module:
=======================================================================================================
for file in `ls $1`
do
    if [ ! -d $file ];then
        continue
    fi
    cd $file
    for file_0 in `ls $1`
    do
        if [ ! -d $file_0 ]; then
            continue
        fi
        cd $file_0
#----------------------
【The critical calculation part is set here】
#----------------------
        cd ..
    done
    cd ..
done
=======================================================================================================


It can be modified to the following form:
=======================================================================================================
for filemag in `cat maglist.txt`
do
    file=`echo $filemag | awk -F ',' '{print $1}'`
    cd $file
#----------------------
【Same details as above for the critical calculation part】
#----------------------
    cd ../../
done
=======================================================================================================
"""


import json
import os
from collections import OrderedDict

import warnings
import re
from glob import glob

from ..calcSets.pwdftSet import InputWriter4pwdft
from ..calcSets.qeSets import InputWriter4qe
from ..calcSets.vaspVaspkitWriter import VaspkitInputWriter
from ..calcSets.vaspSetsWriter import InputWriter
from ..calcSets.vaspPmgWriter import PmgInputWriter
from ..calcSets.vaspShWriter import ShareInp

SUB_PATH = os.path.join(os.path.expanduser("~"), ".config", ".PyHTStack2D.json")

gen_modes = {"basic": InputWriter, "vaspkit": VaspkitInputWriter, "pmg": PmgInputWriter,
             "qe": InputWriter4qe, "pwdft": InputWriter4pwdft}
modes_kwargs = {"basic": InputWriter.__init__.__code__.co_varnames[3:InputWriter.__init__.__code__.co_argcount],
                "vaspkit": VaspkitInputWriter.__init__.__code__.co_varnames[
                           3:VaspkitInputWriter.__init__.__code__.co_argcount],
                "pmg": PmgInputWriter.__init__.__code__.co_varnames[3:VaspkitInputWriter.__init__.__code__.co_argcount],
                "qe": InputWriter4qe.__init__.__code__.co_varnames[3:InputWriter4qe.__init__.__code__.co_argcount],
                "pwdft": InputWriter4pwdft.__init__.__code__.co_varnames[3:InputWriter4pwdft.__init__.__code__.co_argcount]
                }


class GenRunDir:
    def __init__(self, posdir="POSCAR_dir", posname="*", workdir="work", multilevel=None,
                 subset="pbs", mpirun="mpirun", vasp="vasp_std_2D", qe="pw.x", pwdft="pwdft",
                 moduleload="vasp/5.4.4-intel2019",
                 genmode="basic", taskname=None, **kwargs):
        """
        Generate the input directories according to the POSCAR files. The input files are generated by the genmode.
        The input file is stored in the "work" directory in the same path as the directory (posdir) where the POSCAR
        is located.

        posdir: str
            The directory where the POSCAR files are stored.
        posname: str
            Characters contained in the POSCAR file name.
            For example, "*" means all the files in the directory,
            and "*POSCAR*" means the files with "POSCAR" in the name.
        workdir: str
            The directory where the input files are stored.
        multilevel: int
            The number of sub-directories that are used to write the run.sh file for several POSCAR files (stored in a multi-level directory) of the same chemical formula.
            The "posname" and "workdir" parameters are invalid if multilevel is not None.
            For example, if the POSCAR files are stored in the directory "BiPOSCAR_dir/S24P8Ag4V4_0.00%/AA/cord1", the multilevel is 4.
            If the multilevel is None, it means that each directory (formula) has only one POSCAR file.
        subset: str
            Assignment submission mode.
            "pbs": The PBS submission mode.
            "slurm": The SLURM submission mode.
        mpirun: str
            The MPI command.
        vasp: str
            The path of the VASP module or the VASP module name.
            For example, "vasp_std", "vasp_std_2D", "vasp_gam" and so on.
        qe: str
            The path of the Quantum Espresso module or the Quantum Espresso module name.
            For example, "pw.x", "cp.x"
        pwdft: str
                The path of the PWDFT module.
        moduleload: str
            For example, load "vasp/5.4.4-intel2019,intelmpi/2019.update3,mkl/2019.update3",
            use "," to separate the modules.
        genmode: str
            The mode of generating the input files.
            "basic": The basic mode of generating the input files.
            "vaspkit": The mode of generating the input files by Vaspkit.
            "pmg": The mode of generating the input files by pymatgen.
        takname: str
            The name of the task. It is used to rename the input files.
            If tasklist is not None, only the input file will be generated, skipping the generation of the run.sh file

        kwargs: pos_dict (All optional)
            The additional kwargs for the input files.

            "overwrite": bool
                    Whether to overwrite the existing input files.
            "is_print": bool
                    Whether to print the path where the input files are written.
            ----------------------------------------------
            Specified kwargs for the basic mode:
                "inputOpt": str, default="scf"
                    The calculation mode, including 'relax', 'scf', 'band'.
                    Additional suffixes: '-hse06', '-pu' (DFT + U),'-dip' (Dipole correction), <'-d2', '-d3',
                    '-d3bj', '-optpbe', '-optb88', '-optb86b'> (vdW correction).
                    For example, 'scf-d3' means the DFT-D3 no-damping correction static calculation .
                "user_incar_settings": pos_dict
                    User-defined INCAR settings.
                "ini_magmom": bool
                    Whether to initialize the magnetic moments.
                "ini_magmom_val": float
                    The initial magnetic moment value.
                "kselfSet": list
                    Manual k-mesh settings. The length of the kselfSet should be 3, such as [11, 11, 1].
                "kmeshrv": float
                    The k-mesh accuracy level.
                "gamma": bool
                    Whether to use the gamma-centered k-point.
                "is2D": bool
                    Whether the system is 2D. If True, If True, the k-mesh in the z-direction is set to 1.
                "potpath": str
                    The path of the POTCAR file.
            ----------------------------------------------
            Specified kwargs for the vaspkit mode:
                "inputOpt": str
                    The available options are provided in the VASPKIT package, including: ST, SR, MG, SO, D3, H6, PU, MD,
                    GW, BS, DC, EL, BD, OP, EC, PC, FD, DT, NE, DM, FQ and LR.
                    The specific meaning of each option can be found in the VASPKIT package documentation.
                    For example, inputOpt = 'STH6D3' means HSE06-D3 Static-Calcualtion'.
                "kmseshScheme": int
                    1: Monkhorst-Pack Scheme; 2: Gamma-Centered Scheme; 3: Irreducible K-Points with Gamma Scheme.
                "kmeshrv": float
                    The k-mesh accuracy level.
                "bandkpath": int
                    K-Path Options for Band Structure Calculation. 301: 1D Structure; 302: 2D Structure; 303: 3D Structure.
                "Hybridbandkpath": list
                    The k-path for the hybrid band structure calculation. For example, [251, 2, 0.03, 0.04].
                "genpotcar": int
                    Generate POTCAR file 103 with default setting, or 104 with user specified potential.
            ----------------------------------------------
            Specified kwargs for the pmg mode:
                "inputOpt": str
                    The style of the settings in the VASP input file.
                    The available styles are: "MITMD", "MITNEB", "MITRelax", "MPAbsor", "MPHSEBS", "MPHSERelax", "MPMD",
                    "MPMetalRelax", "MPNMR", "MPNonSCF", "MPRelax", "MPSOC", "MPScanRelax", "MPScanStatic", "MPStatic",
                    "MSONable", "MVLElastic", "MVLGB", "MVLGW", "MVLNPTMD", "MVLRelax52", "MVLScanRelax", "MVLSlab",
                    "MatPESStatic".
                "user_incar_settings": pos_dict
                    User-defined INCAR settings.
                    Generally, 99% of tasks require specialization of the INCAR file by user_incar_settings.
                    For example, user_incar_settings = {"NPAR": 4, "EDIFF": 1e-5, , "IVDW": 12,
                    "LDIPOL": "True", "IDIPOL": 3,  "DIPOL": [0.5, 0.5, 0.5]}
        """
        assert genmode.lower() in gen_modes.keys(), f"genmode should be one of {list(gen_modes.keys())}"
        self.posdir = posdir
        self.posname = posname
        if multilevel is None:
            self.multilevel = multilevel
        else:
            assert isinstance(multilevel, int) and multilevel > 0, "multilevel should be an integer greater than 0."
            assert genmode.lower() != "qe" and genmode.lower() != "pwdft", \
                "multilevel is not supported in the QE and PWDFT mode."
            self.multilevel = multilevel - 1
        self.workdir = workdir
        self.genmode_name = genmode.lower()
        self.genmode_ = gen_modes[self.genmode_name]
        self.mkdirsh = True if self.genmode_name == "vaspkit" else False
        self.subset = subset.lower()
        self.mpirun = mpirun
        self.vasp = vasp
        self.qe = qe
        self.pwdft = pwdft
        self.moduleload = moduleload

        self.taskname = taskname  # If taskname is not None, skip the generation of the run.sh file

        self.kwargs = kwargs
        self.runfile = None

        self.failtxt = "rm -f failed.txt"
        self.filecom = "for file in `ls $1`"

        for kwarg in kwargs.keys():
            assert kwarg in modes_kwargs[self.genmode_name], \
                f"kwarg of \"{genmode}\" mode should be one of {modes_kwargs[self.genmode_name]}"

    def gen_input(self):
        """
        Generate the input files for the calculation and/or the run.sh file.
        """
        if self.multilevel:
            self.genmode_ = self.genmode_(posdir=self.posdir, taskname=self.taskname, **self.kwargs)
            self.genmode_.write_input_multi_pos()
        else:
            posfiles = glob(os.path.join(self.posdir, f"*{self.posname}*"))
            self.genmode_ = self.genmode_(posfiles, posdir=self.posdir, workdir=self.workdir, taskname=self.taskname,
                                          **self.kwargs)
            self.genmode_.write_input()

        self.runfile = self.genmode_.runfile

        if self.taskname is None:
            self.gen_runsh()

    def __runsh_base(self):
        with open(self.runfile, "w", newline='\n') as f:
            f.write("#!/bin/bash -x\n")
            if os.path.exists(SUB_PATH):
                sub_set = json.load(open(SUB_PATH, 'r'))
                if self.subset == "pbs" and "PBS_set" in sub_set.keys():
                    for key, value in sub_set["PBS_set"].items():
                        f.write(f"#{key}{value}\n")
                    f.write("\n")
                    if "PBS_echo" in sub_set.keys():
                        for echo_ in sub_set["PBS_echo"]:
                            f.write(f"{echo_}\n")
                    f.write("\ncd $PBS_O_WORKDIR\n")
                elif self.subset == "slurm" and "SLURM_set" in sub_set.keys():
                    for key, value in sub_set["SLURM_set"].items():
                        f.write(f"#{key}{value}\n")
                    f.write("\n")
                    if "SLURM_echo" in sub_set.keys():
                        for echo_ in sub_set["SLURM_echo"]:
                            f.write(f"{echo_}\n")
                    f.write("\ncd $SLURM_SUBMIT_DIR\n")
                else:
                    warnings.warn(
                        f"The parameter subset should be one of ['pbs','slurm'], and check if there are general "
                        f"pbs or slurm settings in ~/.config/.PyHTStack2D.json.\n Due to incomplete job submission "
                        f"settings, only the calculation job is provided. Please complete the contents of run.sh")
            else:
                warnings.warn(
                    f"Due to incomplete job submission settings, only the calculation job is provided. "
                    f"Please complete the contents of run.sh")
            if self.moduleload is not None:
                module_ = self.moduleload.split(",")
                f.write(f"module load")
                for m in module_:
                    f.write(f" {m}")
                f.write("\n")
            if self.mkdirsh:
                f.write(f"bash mkdir.sh\n")
            f.write(f"\nMPI={self.mpirun}\n")
            if self.genmode_name == "qe":
                f.write(f"QE={self.qe}\n")
            elif self.genmode_name == "pwdft":
                f.write(f"PWDFT={self.pwdft}\n")
            else:
                f.write(f"VASP={self.vasp}\n")
            # f.write("\necho \"#################\" >> failed.txt\n")
            f.write("\n" + self.failtxt + "\n")

            f.write("\njobconv='reached'\n")  # Keyword for Convergence
            f.write("jobfinish='Voluntary'\n")  # Keyword for Finish
            f.write(self.filecom + "\n")

    def __runsh_main(self):
        with open(self.runfile, "a", newline='\n') as f:
            f.write("do\n")
            f.write("    if [ ! -d $file ]; then\n")
            f.write("        continue\n")
            f.write("    fi\n")

            f.write("    cd $file\n")
            f.write("#----------------------\n")
            if self.genmode_name == "qe":
                f.write("    $MPI $QE < QE.in > QE.out\n")
                f.write(
                    "    if [ ! -f QE.out ] || [ `grep -c \"JOB DONE.\" QE.out` -eq 0 ]; then\n")
            elif self.genmode_name == "pwdft":
                f.write("    $MPI $PWDFT -in config.yaml -out statfile\n")
                f.write(
                    "    if [ ! -f statfile ]; then\n")
            else:
                f.write("    $MPI $VASP > runlog\n")
                f.write(
                    "    if [ -f runlog ] && [ `grep -c \"or copy CONTCAR\" runlog` -ne 0 ]; then\n")
                f.write("        mv POSCAR POSCAR00\n")
                f.write("        cp CONTCAR POSCAR\n")
                f.write("        $MPI $VASP > runlog\n")
                f.write("    fi\n")
                f.write(
                    "    if [ ! -f OUTCAR ] || [ `grep -c $jobconv OUTCAR` -eq 0 ] || [ `grep -c $jobfinish OUTCAR` -eq 0 ]; then\n")
                # f.write("            echo $file\",\"single-failed >> ../failed.txt\n")
            if self.multilevel is None:
                f.write("        echo $file >> ../failed.txt\n")
            else:
                f.write("        echo $file >> "+"../" * self.multilevel+"failed.txt\n")
            f.write("    fi\n")
            f.write("#----------------------\n")
            if self.multilevel is None:
                f.write("    cd ..\n")
            else:
                f.write("    cd " + "../" * self.multilevel + "\n")
            f.write("done\n")

    def __runsh_multipos_main(self):
        cd_com = "../" * self.multilevel
        lin_com = "../" * (self.multilevel - 1)
        file_path = "$file"
        with open(self.runfile, "a", newline='\n') as f:
            f.write("do\n")
            f.write("    if [ ! -d $file ]; then\n")
            f.write("        continue\n")
            f.write("    fi\n")
            f.write("    cd $file\n")
            for level_i in range(self.multilevel - 1):
                file_path += f"/$file_{level_i}"
                f.write("    " * level_i + f"    for file_{level_i} in `ls $1`\n")
                f.write("    " * level_i + "    do\n")
                f.write("    " * level_i + f"        if [ ! -d $file_{level_i} ]; then\n")
                f.write("    " * level_i + "            continue\n")
                f.write("    " * level_i + "        fi\n")
                f.write("    " * level_i + f"        cd $file_{level_i}\n")
            f.write("#----------------------\n")
            f.write("    " * (self.multilevel - 2) + "        ln -nfs " + lin_com + "INCAR\n")
            f.write("    " * (self.multilevel - 2) + "        ln -nfs " + lin_com + "KPOINTS\n")
            f.write("    " * (self.multilevel - 2) + "        ln -nfs " + lin_com + "POTCAR\n")
            f.write("    " * (self.multilevel - 2) + "        $MPI $VASP > runlog\n")
            f.write("    " * (self.multilevel - 2) +
                    "        if [ ! -f OUTCAR ] || [ `grep -c $jobconv OUTCAR` -eq 0 ] || [ `grep -c $jobfinish OUTCAR` -eq 0 ]; then\n")
            f.write("    " * (self.multilevel - 2) + f"            echo {file_path} >> {cd_com}failed.txt\n")
            f.write("    " * (self.multilevel - 2) + "        fi\n")
            f.write("#----------------------\n")
            for level_i in range(self.multilevel - 1):
                f.write("    " * (self.multilevel - 2 - level_i) + "        cd ..\n")
                f.write("    " * (self.multilevel - 2 - level_i) + "    done\n")
            f.write("    cd ..\n")
            f.write("done\n")

    def gen_runsh(self):
        """
        Generate the run.sh file for the calculation.
        """
        assert self.runfile is not None, "Please provide the run.sh/run_rw.sh path."

        self.__runsh_base()
        if self.multilevel:
            self.__runsh_multipos_main()
        else:
            self.__runsh_main()

    def failrw(self):
        """
        Write the run_rw.sh file to rerun the failed calculation.
        """
        self.failtxt = "mv failed.txt task_dirs.txt"
        self.filecom = "for file in `cat task_dirs.txt`"
        if self.runfile is None:
            if not os.path.exists(self.workdir):
                os.makedirs(self.workdir)
            self.runfile = os.path.join(self.workdir, "run_rw.sh")
        self.__runsh_base()
        self.__runsh_main()

    @staticmethod
    def get_kwargs():
        for mode_ in modes_kwargs.keys():
            print(f"Specified kwargs for the \"{mode_}\" mode: \n {modes_kwargs[mode_]}\n")


class GenMultiSh:
    def __init__(self, tasklist=None, workdir="work", multilevel=None,
                 subset="pbs", mpirun="mpirun", vasp="vasp_std_2D",
                 moduleload="vasp/5.4.4-intel2019", incpath=None, kppath=None, potpath=None,
                 opts=False, failact="break", saveall=False, savefiles=None, checkf=True):
        """
        Generate run.sh when computing multiple tasks, which only supports the VASP calculation.
        Please use the GenMultiQESh class for Quantum ESPRESSO calculations, PWDFT does not currently support multi-task calculations.

        Currently there are only special operations for some specific task names.
        For "opt" or "relax", the CONTCAR is used as the POSCAR for the next calculation.
        For "band", the CHG/CHGCAR of scf calculation is used as the input of band calculation.
        For "hybband", the CHG/CHGCAR and WAVCAR of scf calculation is used as the input of hybrid band calculation.
        Therefore, when it comes to structural optimisation or band structure calculations, and saveall=True, please try to use "opt", "relax", "band" and "hybband" as [tasklist] elements.

        tasklist: list
            The list of task names. For example, ["opt", "scf", "band"].
        workdir: str
            The run.sh file is generated in the workdir.
        multilevel: int
            The number of sub-directories that are used to write the run.sh file for several POSCAR files (stored in a multi-level directory) of the same chemical formula.
            The "posname" and "workdir" parameters are invalid if multilevel is not None.
            For example, if the POSCAR files are stored in the directory "BiPOSCAR_dir/S24P8Ag4V4_0.00%/AA/cord1", the multilevel is 4.
            If the multilevel is None, it means that each directory (formula) has only one POSCAR file.
        subset: str
            Assignment submission mode.
            "pbs": The PBS submission mode.
            "slurm": The SLURM submission mode.
        mpirun: str
            The MPI command.
        vasp: str
            The path of the VASP module or the VASP module name.
            For example, "vasp_std", "vasp_std_2D", "vasp_gam" and so on.
        moduleload: str
            For example, load "vasp/5.4.4-intel2019,intelmpi/2019.update3,mkl/2019.update3",
            use "," to separate the modules.
        incpath: list
            If incpath is not None, the INCAR is shared by all different material calculations.
        kppath: list
            If kppath is not None, the KPOINTS is shared by all different material calculations.
        potpath: str
            If potpath is not None, the POTCAR is shared by all different material calculations.
        opts: bool
            If the task involves structural optimisation, a secondary structural optimisation calculation is performed to try to avoid the first structural optimisation falling into local minima.
        failact: str
            When the calculation fails, the action taken.
            "continue": Continue the next task calculation.
            "break": Stop the remaining tasks and switch to other material calculations.
        saveall: bool
            Whether to save all output files.
            If saveall is True, all tasks will be created the corresponding directory and save all output files.
            If saveall is False, only the output files specified by savefiles will be saved.
        savefiles: list
            Output files retained at the end of each calculation task.
            Only valid when saveall is False.
        checkf: bool
            Whether to check the input files.
            If checkf is True, self.checkfile() will be called to check the input files.
        """
        assert subset.lower() in ["pbs", "slurm"], "subset should be one of ['pbs', 'slurm']"
        assert failact.lower() in ["continue", "break"], "failact should be one of ['continue', 'break']"

        self.workdir = workdir
        if multilevel is None:
            self.multilevel = multilevel
        else:
            assert isinstance(multilevel, int) and multilevel > 0, "multilevel should be an integer greater than 0."
            self.multilevel = multilevel - 1
        self.runfile = os.path.join(self.workdir, "run.sh")
        self.saveall = saveall
        if tasklist is None:
            self.tasklist0 = None
        else:
            assert isinstance(tasklist, list), "Please provide a list of task names."
            self.tasklist0 = tasklist.copy()
        failtask = self.read_failtask()

        if failtask is None:
            assert isinstance(tasklist, list), "Please provide a list of task names."
            tasklist_ = tasklist
        else:
            tasklist_ = failtask
            self.runfile = os.path.join(self.workdir, "run_rw.sh")

        if self.saveall is False:
            assert savefiles is None or isinstance(savefiles, list), "Please provide a list of save files."
            if savefiles is None:
                savefiles = ["runlog", "CONTCAR", "OUTCAR", "OSZICAR", "vasprun.xml"]

        # tasklist_ = tasklist if failtask is None else failtask

        self.subset = subset.lower()
        self.mpirun = mpirun
        self.vasp = vasp
        self.moduleload = moduleload

        self.bandtask = []
        self.task_init(tasklist=tasklist_, incpath=incpath, kppath=kppath, potpath=potpath)
        self.opts = opts

        self.failact = failact.lower()
        self.savefiles = savefiles
        self.checkf = checkf
        # self.kwargs = kwargs
        self.mkdirsh = os.path.exists(os.path.join(self.workdir, "mkdir.sh"))

    def read_failtask(self):
        return None

    def task_init(self, tasklist, incpath, kppath, potpath):
        self.tasklist = [task_.lower() for task_ in tasklist]
        self.shareInp = ShareInp(workdir=self.workdir, incpath=incpath, kppath=kppath, potpath=potpath,
                                 tasklist=self.tasklist)
        self.opt = None
        if "opt" in self.tasklist or "relax" in self.tasklist:
            self.opt = "opt" if "opt" in self.tasklist else "relax"
            index_opt = self.tasklist.index(self.opt)
            if index_opt != 0:
                warnings.warn("The opt task should be the first task.")
            self.runtask = self.tasklist[1:self.shareInp.ntask]
        else:
            self.runtask = self.tasklist[:self.shareInp.ntask]
        self.wrt = " ".join(self.runtask)
        if "scf" not in self.runtask:
            assert "band" not in self.runtask and "hybband" not in self.runtask, \
                "SCF calculations must be performed prior to band structure calculations."
        else:
            if "band" in self.runtask:
                self.bandtask.append("band")
                scf_index, band_index = self.runtask.index("scf"), self.runtask.index("band")
                if scf_index > band_index:
                    warnings.warn("SCF calculations must be performed prior to band structure calculations.")
                    self.runtask[scf_index], self.runtask[band_index] = self.runtask[band_index], self.runtask[
                        scf_index]
            if "hybband" in self.runtask:
                self.bandtask.append("hybband")
                scf_index, hybband_index = self.runtask.index("scf"), self.runtask.index("hybband")
                if scf_index > hybband_index:
                    warnings.warn("SCF calculations must be performed prior to band structure calculations.")
                    self.runtask[scf_index], self.runtask[hybband_index] = self.runtask[hybband_index], self.runtask[
                        scf_index]
        self.incshare, self.kpshare, self.potshare = self.shareInp.is_share()

    def checkfile(self, filepefix=None):
        """
        Check the existence of input files.

        filepefix: list
            The prefix of the input files.
            If the input files are INCAR-scf, KPOINTS-scf, the filepefix is ["INCAR", "KPOINTS"].
        """
        if filepefix:
            posdir = os.listdir(self.workdir)
            for pos in posdir:
                if os.path.isdir(os.path.join(self.workdir, pos)):
                    pos_path = os.path.join(self.workdir, pos)
                    for task_ in self.runtask:
                        for file_ in filepefix:
                            assert os.path.exists(os.path.join(pos_path, file_ + "-" + task_)), \
                                f"File {file_}-{task_} does not exist in {pos_path}. \nIf you are using the vaspkit package " \
                                f"to generate input files, check for the existence of the mkdir.sh file in the working directory and run it."
        else:
            pass

    def runsh_base(self):
        with open(self.runfile, "w", newline='\n') as f:
            f.write("#!/bin/bash -x\n")
            if os.path.exists(SUB_PATH):
                sub_set = json.load(open(SUB_PATH, 'r'))
                if self.subset == "pbs" and "PBS_set" in sub_set.keys():
                    for key, value in sub_set["PBS_set"].items():
                        f.write(f"#{key}{value}\n")
                    f.write("\n")
                    if "PBS_echo" in sub_set.keys():
                        for echo_ in sub_set["PBS_echo"]:
                            f.write(f"{echo_}\n")
                    f.write("\ncd $PBS_O_WORKDIR\n")
                elif self.subset == "slurm" and "SLURM_set" in sub_set.keys():
                    for key, value in sub_set["SLURM_set"].items():
                        f.write(f"#{key}{value}\n")
                    f.write("\n")
                    if "SLURM_echo" in sub_set.keys():
                        for echo_ in sub_set["SLURM_echo"]:
                            f.write(f"{echo_}\n")
                    f.write("\ncd $SLURM_SUBMIT_DIR\n")
                else:
                    warnings.warn(
                        f"The parameter subset should be one of ['pbs','slurm'], and check if there are general "
                        f"pbs or slurm settings in ~/.config/.PyHTStack2D.json.\n Due to incomplete job submission "
                        f"settings, only the calculation job is provided. Please complete the contents of run.sh")
            else:
                warnings.warn(
                    f"Due to incomplete job submission settings, only the calculation job is provided. "
                    f"Please complete the contents of run.sh")
            if self.moduleload is not None:
                module_ = self.moduleload.split(",")
                f.write(f"module load")
                for m in module_:
                    f.write(f" {m}")
                f.write("\n")
            f.write(f"\nMPI={self.mpirun}\n")
            f.write(f"VASP={self.vasp}\n")
            f.write("\necho \"#################\" >> failed.txt\n")

            f.write("\njobconv='reached'\n")  # Keyword for Convergence
            f.write("jobfinish='Voluntary'\n")  # Keyword for Finish

            if self.mkdirsh:
                warnings.warn("There is a mkdir.sh file in the working directory. It will run the mkdir.sh file first. "
                              "Please check the contents of the mkdir.sh file.")
                f.write(f"\nbash mkdir.sh\n\n")

    def gen_runsh(self):
        for task_ in self.runtask:
            if "band" in task_:
                if task_ not in ["band", "hybband"]:
                    warnings.warn(
                        "Please check the task name, it is better to use one of the keywords ['band', 'hybband'].")
                    self.note()

        sharecommend = self.get_sharecommend()
        self.runsh_base()

        if self.saveall:
            self.full_save(sharecommend)
        else:
            self.part_save(sharecommend)

    def get_sharecommend(self):
        if self.multilevel:
            lin_com = "../" * (self.multilevel - 1)
        else:
            lin_com = ""
        if self.saveall:
            if not self.incshare and not self.kpshare:
                filepefix = ["INCAR", "KPOINTS"]
                sharecommend = ["ln -nfs " + lin_com + "../INCAR-$task INCAR", "ln -nfs " + lin_com + "../KPOINTS-$task KPOINTS"]
            elif not self.incshare and self.kpshare:
                filepefix = ["INCAR"]
                sharecommend = ["ln -nfs " + lin_com + "../INCAR-$task INCAR", "ln -nfs " + lin_com + "../../KPOINTS-$task KPOINTS"]
            elif self.incshare and not self.kpshare:
                filepefix = ["KPOINTS"]
                sharecommend = ["ln -nfs " + lin_com + "../../INCAR-$task INCAR", f"ln -nfs " + lin_com + "../KPOINTS-$task KPOINTS"]
            else:
                filepefix = None
                sharecommend = ["ln -nfs " + lin_com + "../../INCAR-$task INCAR", "ln -nfs " + lin_com + "../../KPOINTS-$task KPOINTS"]
        else:
            if not self.incshare and not self.kpshare:
                filepefix = ["INCAR", "KPOINTS"]
                sharecommend = ["cp " + lin_com + "INCAR-$task INCAR", "cp " + lin_com + "KPOINTS-$task KPOINTS"]
            elif not self.incshare and self.kpshare:
                filepefix = ["INCAR"]
                sharecommend = ["cp " + lin_com + "INCAR-$task INCAR", "ln -nfs " + lin_com + "../KPOINTS-$task KPOINTS"]
            elif self.incshare and not self.kpshare:
                filepefix = ["KPOINTS"]
                sharecommend = ["ln -nfs " + lin_com + "../INCAR-$task INCAR", f"cp " + lin_com + "KPOINTS-$task KPOINTS"]
            else:
                filepefix = None
                sharecommend = ["ln -nfs " + lin_com + "../INCAR-$task INCAR", "ln -nfs " + lin_com + "../KPOINTS-$task KPOINTS"]
        if self.checkf:
            self.checkfile(filepefix=filepefix)
        return sharecommend

    def part_save(self, sharecommend):
        if self.multilevel:
            cd_com = "../" * (self.multilevel - 1)
            multi_ = self.multilevel-1
        else:
            cd_com = ""
            multi_ = 0
        file_path = "$file"

        with open(self.runfile, "a", newline="\n") as f:
            f.write(f"tasklist=({self.wrt})\n")
            f.write("\nfor file in `ls $1`\n")
            f.write("do\n")
            f.write("    if [ ! -d $file ];then\n")
            f.write("        continue\n")
            f.write("    fi\n")
            f.write("    cd $file\n")
            if self.potshare:
                f.write("#----------------------\n")
                f.write("    ln -nfs ../POTCAR POTCAR\n")
                f.write("#----------------------\n")

            for level_i in range(multi_):
                file_path += f"/$file_{level_i}"
                f.write("    " * level_i + f"    for file_{level_i} in `ls $1`\n")
                f.write("    " * level_i + "    do\n")
                f.write("    " * level_i + f"        if [ ! -d $file_{level_i} ]; then\n")
                f.write("    " * level_i + "            continue\n")
                f.write("    " * level_i + "        fi\n")
                f.write("    " * level_i + f"        cd $file_{level_i}\n")
            f.write("#----------------------\n")
            if self.multilevel:
                f.write("    " * multi_ + f"    ln -nfs {cd_com}POTCAR POTCAR\n")

            if self.opt is not None:
                optsharecom = [re.sub(r'\$task', self.opt, cmd) for cmd in sharecommend]
                f.write("# Optimize Structure\n")
                f.write("    " * multi_ + f"    {optsharecom[0]}\n")
                f.write("    " * multi_ + f"    {optsharecom[1]}\n")
                f.write("    " * multi_ + "    $MPI $VASP > runlog\n")
                f.write("    " * multi_ +
                    "    if [ -f runlog ] && [ `grep -c \"or copy CONTCAR\" runlog` -ne 0 ]; then\n")
                f.write("    " * multi_ + "        mv POSCAR POSCAR00\n")
                f.write("    " * multi_ + "        cp CONTCAR POSCAR\n")
                f.write("    " * multi_ + "        $MPI $VASP > runlog\n")
                f.write("    " * multi_ + "    fi\n")
                f.write("    " * multi_ + "    if [ ! -f runlog ] || [ `grep -c \"reached required accuracy\" runlog` -eq 0 ];then\n")
                f.write("    " * multi_ + "        cd ..\n")
                f.write("    " * multi_ + f"        echo {file_path}\",\"{self.opt}-failed >> {cd_com}failed.txt\n")
                f.write("    " * multi_ +
                    "        continue  # As the structural optimisation did not converge, no further calculations were performed for this material.\n")
                f.write("    " * multi_ + "    fi\n")
                f.write("    " * multi_ + "    mv POSCAR POSCAR0\n")
                f.write("    " * multi_ + "    cp CONTCAR POSCAR\n")
                for savefile in self.savefiles:
                    f.write("    " * multi_ + f"    mv {savefile} {savefile}-{self.opt}\n")

                if self.opts:
                    f.write("# Optimize Structure Again\n")
                    f.write("    " * multi_ + "    $MPI $VASP > runlog\n")
                    f.write("    " * multi_ + "    if [ ! -f runlog ] || [ `grep -c \"reached required accuracy\" runlog` -eq 0 ];then\n")
                    f.write("    " * multi_ + "        cd ..\n")
                    f.write("    " * multi_ + f"        echo {file_path}\",\"{self.opt}-s-failed >> {cd_com}failed.txt\n")
                    f.write("    " * multi_ + "        continue  # No further calculations were performed for this material.\n")
                    f.write("    " * multi_ + "    fi\n")
                    f.write("    " * multi_ + "    mv POSCAR POSCAR1\n")
                    f.write("    " * multi_ + "    cp CONTCAR POSCAR\n")
                    for savefile in self.savefiles:
                        f.write("    " * multi_ + f"    mv {savefile}-{self.opt} {savefile}-{self.opt}0\n")
                        f.write("    " * multi_ + f"    mv {savefile} {savefile}-{self.opt}\n")

            f.write(f"# {self.wrt}\n")
            f.write("    " * multi_ + "    for task in ${tasklist[@]}\n")
            f.write("    " * multi_ + "    do\n")
            f.write("    " * multi_ + f"        {sharecommend[0]}\n")
            f.write("    " * multi_ + f"        {sharecommend[1]}\n")
            f.write("    " * multi_ + "        $MPI $VASP > runlog\n")
            for savefile in self.savefiles:
                f.write("    " * multi_ + f"        cp {savefile} {savefile}-$task\n")
            f.write("    " * multi_ +
                "        if [ ! -f OUTCAR ] || [ `grep -c $jobconv OUTCAR` -eq 0 ] || [ `grep -c $jobfinish OUTCAR` -eq 0 ]; then\n")
            f.write("    " * multi_ + f"            echo {file_path}\",\"$task-failed >> {cd_com}../failed.txt\n")
            f.write("    " * multi_ + f"            {self.failact}\n")
            f.write("    " * multi_ + "        fi\n")
            f.write("    " * multi_ + "    done\n")
            f.write("#----------------------\n")
            for level_i in range(multi_):
                f.write("    " * (multi_ - 1 - level_i) + "        cd ..\n")
                f.write("    " * (multi_ - 1 - level_i) + "    done\n")

            f.write("    cd ..\n")
            f.write("done\n")

    def full_save(self, sharecommend):
        if self.multilevel:
            cd_com = "../" * (self.multilevel - 1)
            multi_ = self.multilevel-1
        else:
            cd_com = ""
            multi_ = 0
        file_path = "$file"
        wrt_ = " ".join([x for x in self.runtask if x not in self.bandtask])

        with open(self.runfile, "a", newline="\n") as f:
            f.write(f"tasklist=({wrt_})\n")
            f.write("\nfor file in `ls $1`\n")
            f.write("do\n")
            f.write("    if [ ! -d $file ];then\n")
            f.write("        continue\n")
            f.write("    fi\n")
            f.write("    cd $file\n")
            if self.potshare:
                f.write("#----------------------\n")
                f.write("    ln -nfs ../POTCAR POTCAR\n")
                f.write("#----------------------\n")

            for level_i in range(multi_):
                file_path += f"/$file_{level_i}"
                f.write("    " * level_i + f"    for file_{level_i} in `ls $1`\n")
                f.write("    " * level_i + "    do\n")
                f.write("    " * level_i + f"        if [ ! -d $file_{level_i} ]; then\n")
                f.write("    " * level_i + "            continue\n")
                f.write("    " * level_i + "        fi\n")
                f.write("    " * level_i + f"        cd $file_{level_i}\n")

            f.write("#----------------------\n")
            if self.multilevel:
                f.write("    " * multi_ + f"    ln -nfs {cd_com}POTCAR POTCAR\n")

            if self.opt is not None:
                optsharecom = [re.sub(r'\$task', self.opt, cmd) for cmd in sharecommend]
                f.write("# Optimize Structure\n")
                f.write("    " * multi_ + f"    if [ ! -d {self.opt} ]; then\n")
                f.write("    " * multi_ + f"        mkdir {self.opt}\n")
                f.write("    " * multi_ + "    fi\n")
                f.write("    " * multi_ + f"    cd {self.opt}\n")
                f.write("    " * multi_ + f"    cp ../POSCAR POSCAR\n")
                f.write("    " * multi_ + f"    ln -nfs ../POTCAR POTCAR\n")
                f.write("    " * multi_ + f"    {optsharecom[0]}\n")
                f.write("    " * multi_ + f"    {optsharecom[1]}\n")
                f.write("    " * multi_ + "    $MPI $VASP > runlog\n")
                f.write("    " * multi_ +
                        "    if [ -f runlog ] && [ `grep -c \"or copy CONTCAR\" runlog` -ne 0 ]; then\n")
                f.write("    " * multi_ + "        mv POSCAR POSCAR00\n")
                f.write("    " * multi_ + "        cp CONTCAR POSCAR\n")
                f.write("    " * multi_ + "        $MPI $VASP > runlog\n")
                f.write("    " * multi_ + "    fi\n")
                f.write("    " * multi_ + "    if [ ! -f runlog ] || [ `grep -c \"reached required accuracy\" runlog` -eq 0 ];then\n")
                f.write("    " * multi_ + "        cd ../..\n")
                f.write("    " * multi_ + f"        echo {file_path}\",\"{self.opt}-failed >> {cd_com}failed.txt\n")
                f.write("    " * multi_ +
                    "        continue  # As the structural optimisation did not converge, no further calculations were performed for this material.\n")
                f.write("    " * multi_ + "    fi\n")
                f.write("    " * multi_ + "    mv POSCAR POSCAR0\n")
                f.write("    " * multi_ + "    cp CONTCAR ../POSCAR\n")
                if self.opts:
                    f.write("# Optimize Structure Again\n")
                    # f.write("        mv POSCAR POSCAR0\n")
                    f.write("    " * multi_ + "    cp CONTCAR POSCAR\n")
                    f.write("    " * multi_ + "    $MPI $VASP > runlog\n")
                    f.write("    " * multi_ + "    if [ ! -f runlog ] || [ `grep -c \"reached required accuracy\" runlog` -eq 0 ];then\n")
                    f.write("    " * multi_ + "        cd ../..\n")
                    f.write("    " * multi_ + f"        echo {file_path}\",\"{self.opt}-s-failed >> {cd_com}failed.txt\n")
                    f.write("    " * multi_ + "        continue  # No further calculations were performed for this material. \n")
                    f.write("    " * multi_ + "    fi\n")
                    f.write("    " * multi_ + "    mv POSCAR POSCAR1\n")
                    f.write("    " * multi_ + "    cp CONTCAR ../POSCAR\n")
                f.write("    " * multi_ + "    cd ../\n\n")

            f.write("    " * multi_ + "    for task in ${tasklist[@]}\n")
            f.write("    " * multi_ + "    do\n")
            f.write("    " * multi_ + "        if [ ! -d $task ]; then\n")
            f.write("    " * multi_ + "            mkdir $task\n")
            f.write("    " * multi_ + "        fi\n")
            f.write("    " * multi_ + "        cd $task\n")
            f.write("    " * multi_ + "        ln -nfs ../POSCAR POSCAR\n")
            f.write("    " * multi_ + "        ln -nfs ../POTCAR POTCAR\n")
            f.write("    " * multi_ + f"        {sharecommend[0]}\n")
            f.write("    " * multi_ + f"        {sharecommend[1]}\n")
            f.write("    " * multi_ + "        $MPI $VASP > runlog\n")
            f.write("    " * multi_ +
                "        if [ ! -f OUTCAR ] || [ `grep -c $jobconv OUTCAR` -eq 0 ] || [ `grep -c $jobfinish OUTCAR` -eq 0 ]; then\n")
            f.write("    " * multi_ + "            cd ..\n")
            f.write("    " * multi_ + f"            echo {file_path}\",\"$task-failed >> {cd_com}../failed.txt\n")
            f.write("    " * multi_ + f"            {self.failact}\n")
            f.write("    " * multi_ + "        fi\n")
            f.write("    " * multi_ + "        cd ..\n")
            f.write("    " * multi_ + "    done\n\n")

            if len(self.bandtask) != 0:
                for band_ in self.bandtask:
                    bandsharecom = [re.sub(r'\$task', band_, cmd) for cmd in sharecommend]
                    f.write("    " * multi_ + f"    if [ ! -d {band_} ]; then\n")
                    f.write("    " * multi_ + f"        mkdir {band_}\n")
                    f.write("    " * multi_ + "    fi\n")
                    f.write("    " * multi_ + f"    cd {band_}\n")
                    f.write("    " * multi_ + "    ln -nfs ../POSCAR POSCAR\n")
                    f.write("    " * multi_ + "    ln -nfs ../POTCAR POTCAR\n")
                    f.write("    " * multi_ + f"    {bandsharecom[0]}\n")
                    f.write("    " * multi_ + f"    {bandsharecom[1]}\n")
                    if "band" in band_:
                        f.write("    " * multi_ + "    ln -nfs ../scf/CHG CHG\n")
                        f.write("    " * multi_ + "    ln -nfs ../scf/CHGCAR CHGCAR\n")
                    if "hyb" in band_:
                        f.write("    " * multi_ + "    ln -nfs ../scf/WAVECAR WAVECAR\n")
                    f.write("    " * multi_ + "    $MPI $VASP > runlog\n")
                    f.write("    " * multi_ +
                        "    if [ ! -f OUTCAR ] || [ `grep -c $jobconv OUTCAR` -eq 0 ] || [ `grep -c $jobfinish OUTCAR` -eq 0 ]; then\n")
                    f.write("    " * multi_ + f"        echo {file_path}\",\"{band_}-failed >> {cd_com}../../failed.txt\n")
                    f.write("    " * multi_ + "    fi\n")
                    f.write("    " * multi_ + "    cd ..\n")
            f.write("#----------------------\n\n")

            for level_i in range(multi_):
                f.write("    " * (multi_ - 1 - level_i) + "        cd ..\n")
                f.write("    " * (multi_ - 1 - level_i) + "    done\n")
            f.write("    cd ..\n")
            f.write("done\n")

    @staticmethod
    def note():
        print("""If structural optimisation is involved, please use the keyword "opt" or "relax" as the task name and 
        place it at the top of the "tasklist" as the first task to be calculated. This task involves copying CONTCAR 
        as a new POSCAR.\n If band calculation is involved, please use the keywords "scf", "band" and "hybband" (
        corresponding to static, band and hybrid functional band calculation respectively) as task names. When 
        "saveall" is True, we need to read the CHG/CHGCAR information from scf for band calculation (e.g. PBE band 
        structure). For hybband calculation (e.g. HSE06 energy band) the WAVECAR and CHG/CHGCAR are required in the 
        scf calculation step. """)


class GenMultiQESh(GenMultiSh):
    """
    This class is used to generate a bash script to rerun the failed multiple tasks, which only supports Quantum ESPRESSO calculation.
    """
    def runsh_base(self, qe="pw.x", moduleload="qe/7.0"):
        with open(self.runfile, "w", newline='\n') as f:
            f.write("#!/bin/bash -x\n")
            if os.path.exists(SUB_PATH):
                sub_set = json.load(open(SUB_PATH, 'r'))
                if self.subset == "pbs" and "PBS_set" in sub_set.keys():
                    for key, value in sub_set["PBS_set"].items():
                        f.write(f"#{key}{value}\n")
                    f.write("\n")
                    if "PBS_echo" in sub_set.keys():
                        for echo_ in sub_set["PBS_echo"]:
                            f.write(f"{echo_}\n")
                    f.write("\ncd $PBS_O_WORKDIR\n")
                elif self.subset == "slurm" and "SLURM_set" in sub_set.keys():
                    for key, value in sub_set["SLURM_set"].items():
                        f.write(f"#{key}{value}\n")
                    f.write("\n")
                    if "SLURM_echo" in sub_set.keys():
                        for echo_ in sub_set["SLURM_echo"]:
                            f.write(f"{echo_}\n")
                    f.write("\ncd $SLURM_SUBMIT_DIR\n")
                else:
                    warnings.warn(
                        f"The parameter subset should be one of ['pbs','slurm'], and check if there are general "
                        f"pbs or slurm settings in ~/.config/.PyHTStack2D.json.\n Due to incomplete job submission "
                        f"settings, only the calculation job is provided. Please complete the contents of run.sh")
            else:
                warnings.warn(
                    f"Due to incomplete job submission settings, only the calculation job is provided. "
                    f"Please complete the contents of run.sh")
            if moduleload is not None:
                module_ = moduleload.split(",")
                f.write(f"module load")
                for m in module_:
                    f.write(f" {m}")
                f.write("\n")
            f.write(f"\nMPI={self.mpirun}\n")
            f.write(f"QE={qe}\n")
            f.write("\necho \"#################\" >> failed.txt\n")

    def gen_runsh(self, qe="pw.x", moduleload="qe/7.0"):
        assert self.multilevel is None, "The multi-level directory is not supported for Quantum ESPRESSO calculation."
        self.runsh_base(qe=qe, moduleload=moduleload)
        with open(self.runfile, "a", newline="\n") as f:
            f.write("\nfor file in `ls $1`\n")
            f.write("do\n")
            f.write("    if [ ! -d $file ];then\n")
            f.write("        continue\n")
            f.write("    fi\n")
            f.write("    cd $file\n")
            f.write("#----------------------\n")
            for task_ in self.tasklist:
                f.write(f"    $MPI $QE <{task_}-QE.in> {task_}-QE.out\n")
                f.write(f"    if [ ! -f {task_}-QE.out ] || [ `grep -c 'JOB DONE' {task_}-QE.out` -eq 0 ]; then\n")
                f.write(f"        echo $file\",\"{task_}-failed >> ../failed.txt\n")
                f.write(f"        {self.failact}\n")
                f.write("    fi\n")
            f.write("#----------------------\n")
            f.write("    cd ..\n")
            f.write("done\n")